# 网络与安全

## 网络分层

网络协议体系结构的两种国际标准。
* 理论上的国际标准 OSI网络协议体系
* 事实上的国际标准 TCP/IP网络协议体系

OSI七层协议

![](./images/osi.jpeg)


TCP/IP四层协议

![](./images/tcp.jpeg)

TCP/IP四层体系结构最下层的网络接口层并没有具体内容，因此往往采取折中的方法，即综合OSI和TCP/IP的优点，采用一种只有五层协议的体系结构。

![](./images/network.jpeg)

**物理层协议：**

负责0、1 比特流（0/1序列）与电压的高低、逛的闪灭之间的转换。规定了激活、维持、关闭通信端点之间的机械特性、电气特性、功能特性以及过程特性；该层为上层协议提供了一个传输数据的物理媒体，只是说明标准。
在这一层，数据的单位称为比特（bit）（注：bit和字节Byte，我们常说的1字节8位2进制即：1B=8bit）。属于物理层定义的典型规范代表包括：EIA/TIA RS-232、EIA/TIA RS-449、V.35、RJ-45、fddi令牌环网。

**数据链路层协议：**

负责物理层面上的互联的、节点间的通信传输（例如一个以太网项链的2个节点之间的通信）；该层的作用包括：物理地址寻址、数据的成帧、流量控制、数据的检错、重发等。
在这一层，数据的单位称为帧（frame）。数据链路层协议的代表包括：ARP、RARP、SDLC、HDLC、PPP、STP、帧中继等。

**网络层协议：**

将数据传输到目标地址；目标地址可以使多个网络通过路由器连接而成的某一个地址，主要负责寻找地址和路由选择，网络层还可以实现拥塞控制、网际互连等功能。在这一层，数据的单位称为数据包（packet）。网络层协议的代表包括：IP、IPX、RIP、OSPF等。

**传输层协议（核心层）：**

传输层是OSI中最重要、最关键的一层,是唯一负责总体的数据传输和数据控制的一层；

传输层提供端到端的交换数据的机制，检查分组编号与次序，传输层对其上三层如会话层等，提供可靠的传输服务,对网络层提供可靠的目的地站点信息主要功能。

在这一层，数据的单位称为数据段（segment）。主要功能：

1：为端到端连接提供传输服务。

2：这种传输服务分为可靠和不可靠的,其中TCP是典型的可靠传输,而UDP则是不可靠传输。

3：为端到端连接提供流量控制,差错控制,服务质量(Quality of Service,QoS)等管理服务。

包括的协议如下：

TCP：传输控制协议，传输效率低，可靠性强。

UDP：用户数据报协议，适用于传输可靠性要求不高，数据量小的数据。

DCCP、SCTP、RTP、RSVP、PPTP等协议。

**会话层协议：**

负责建立和断开通信连接（数据流动的逻辑通路），记忆数据的分隔等数据传输相关的管理。

**表示层协议：**

将数据格式转换为标准格式。将应用处理的信息转换为适合网络传输的格式，或将来自下一层的数据转换为上层能够处理的格式；主要负责数据格式的转换，确保一个系统的应用层信息可被另一个系统应用层读取。具体来说，就是将设备固有的数据格式转换为网络标准传输格式，不同设备对同一比特流解释的结果可能会不同；因此，主要负责使它们保持一致。

**应用层协议：**

1：超文本传输协议HTTP：这是一种最基本的客户机/服务器的访问协议；浏览器向服务器发送请求，而服务器回应相应的网页。

2：文件传送协议FTP：提供交互式的访问，基于客户服务器模式，面向连接 使用TCP可靠的运输服务。主要功能:减少/消除不同操作系统下文件的不兼容性。

3：远程登录协议TELNET：客户服务器模式，能适应许多计算机和操作系统的差异，网络虚拟终端NVT的意义。

4：简单邮件传送协议SMTP：Client/Server模式，面向连接。基本功能：写信、传送、报告传送情况、显示信件、接收方处理信件。

5：DNS域名解析协议：DNS是一种用以将域名转换为IP地址的Internet服务。

6：简单文件传送协议TFTP：客户服务器模式，使用UDP数据报，只支持文件传输，不支持交互，TFTP代码占内存小。

7：简单网络管理协议（SNMP）: SNMP模型的4个组件：被管理结点、管理站、管理信息、管理协议。SNMP代理：运行SNMP管理进程的被管理结点。

8：DHCP动态主机配置协议: 发现协议中的引导文件名、空终止符、属名或者空,DHCP供应协议中的受限目录路径名 Options –可选参数字段，参考定义选择列表中的选择文件。

## TCP协议

TCP(Transmission Control Protocol 传输控制协议)是一种面向连接的、可靠的、基于字节流的传输层通信协议。

TCP协议具有的特点：
* 基于流的方式
* 面向连接的传输层协议
* 可靠通信方式
* 在网络状况不佳的时候尽量降低系统由于重传带来的带宽开销
* 通信连接维护是面向通信的两个端点的，而不考虑中间网段和节点

### TCP报文头部

![](./images/tcpheader.png)

对于 TCP 头部来说，以下几个字段是很重要的

* Sequence number，这个序号保证了 TCP 传输的报文都是有序的，对端可以通过序号顺序的拼接报文
* Acknowledgement Number，这个序号表示数据接收端期望接收的下一个字节的编号是多少，同时也表示上一个序号的数据已经收到
* Window Size，窗口大小，表示还能接收多少字节的数据，用于流量控制
* 标识符
  * URG=1：该字段为一表示本数据报的数据部分包含紧急信息，是一个高优先级数据报文，此时紧急指针有效。紧急数据一定位于当前数据包数据部分的最前面，紧急指针标明了紧急数据的尾部。
  * ACK=1：该字段为一表示确认号字段有效。此外，TCP 还规定在连接建立后传送的所有报文段都必须把 ACK 置为一。
  * PSH=1：该字段为一表示接收端应该立即将数据 push 给应用层，而不是等到缓冲区满后再提交。
  * RST=1：该字段为一表示当前 TCP 连接出现严重问题，可能需要重新建立 TCP 连接，也可以用于拒绝非法的报文段和拒绝连接请求。
  * SYN=1：当SYN=1，ACK=0时，表示当前报文段是一个连接请求报文。当SYN=1，ACK=1时，表示当前报文段是一个同意建立连接的应答报文。
  * FIN=1：该字段为一表示此报文段是一个释放连接的请求报文。


### TCP状态机

HTTP 是无连接的，所以作为下层的 TCP 协议也是无连接的，虽然看似 TCP 将两端连接了起来，但是其实只是两端共同维护了一个状态。

![](./images/tcpstatus.png)


### TCP的工作方式

如下图TCP的通信过程所示：

![](./images/connect.jpeg)


#### 建立连接（三次握手）

建立一个TCP连接时需要三次握手，指的是客户端和服务端总共发送3个包以确认连接的建立。

1. 第一次握手 客户端发送SYN（seq=x）报文给服务器端,进入SYN_SENT状态，等待服务器确认

2. 第二次握手 服务器端收到SYN报文，回应一个SYN （seq=y）ACK（ACK=x+1）报文，进入SYN_RCVD状态。

3. 第三次握手 客户端收到服务器端的SYN报文，回应一个ACK（ACK=y+1）报文，进入ESTABLISHED状态。



#### 连接终止（四次挥手）

建立一个连接需要三次握手，而终止一个连接要经过四次握手，这是由TCP的半关闭（half-close）造成的

四次挥手（Four-Way Wavehand）指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。

1. 第一次挥手 客户端发送一个 FIN ，用来关闭客户端到服务端的数据传送，客户端进入 FIN_WAIT_1 状态。

2. 第二次挥手 服务端收到 FIN 后，发送一个 ACK 给客户端，确认序号为收到序号+1，服务端进入 CLOSE_WAIT 状态。

3. 第三次挥手 服务端发送一个 FIN ，用来关闭服务端到客户端的数据传送，服务端进入 LAST_ACK 状态。

4. 第四次挥手 客户端收到 FIN 后，客户端进入 TIME_WAIT 状态，接着发送一个 ACK 给服务端，确认序号为收到序号+1，服务端进入 CLOSED 状态，完成四次挥手。

### ARQ协议

ARQ协议也就是超时重传机制。通过确认和超时机制保证了数据的正确送达，ARQ协议包含停止等待ARQ和连续ARQ

#### 停止等待ARQ

**正常传输过程**

只要A向B发送一段报文，都要停止发送并启动一个定时器，等待对端响应，在定时器时间内接受到对端应答就取消定时器发送下一段报文

**报文丢失或出错**

在报文的传输过程中可能会出现丢包的情况。这时候超过定时器设定的时间就会再次发送丢包的数据直到对端响应，所以需要每次都备份发送的数据。

即使报文正常的传输到对端，也可能出现在传输过程中报文报错的问题。这时候对端会抛弃该报文并等待重传。

PS：一般定时器设定的时间都会大于一个 RTT 的平均时间。RTT 表示发送端发送数据到接收到对端数据所需的往返时间。

**ACK 超时或丢失**

对端传输的应答也可能出现丢失或超时的情况。那么超过定时器时间 A 端照样会重传报文。这时候 B 端收到相同序号的报文会丢弃该报文并重传应答，直到 A 端发送下一个序号的报文。

在超时的情况下也可能出现应答很迟到达，这时 A 端会判断该序号是否已经接收过，如果接收过只需要丢弃应答即可。

这个协议的缺点就是传输效率低，在良好的网络环境下每次发送报文都得等待对端的 ACK 。

#### 连续ARQ

在连续 ARQ 中，发送端拥有一个发送窗口，可以在没有收到应答的情况下持续发送窗口内的数据，这样相比停止等待 ARQ 协议来说减少了等待时间，提高了效率。

**累计确认**

连续 ARQ 中，接收端会持续不断收到报文。如果和停止等待 ARQ 中接收一个报文就发送一个应答一样，就太浪费资源了。通过累计确认，可以在收到多个报文以后统一回复一个应答报文。报文中的 ACK 可以用来告诉发送端这个序号之前的数据已经全部接收到了，下次请发送这个序号 + 1的数据。

但是累计确认也有一个弊端。在连续接收报文时，可能会遇到接收到序号 5 的报文后，并未接到序号 6 的报文，然而序号 7 以后的报文已经接收。遇到这种情况时，ACK 只能回复 6，这样会造成发送端重复发送数据，这种情况下可以通过 Sack 来解决，这个会在下文说到

### 滑动窗口

在上面小节中讲到了发送窗口。在 TCP 中，两端都维护着窗口：分别为发送端窗口和接收端窗口。

发送端窗口包含已发送但未收到应答的数据和可以发送但是未发送的数据。


![](./images/tcpwindow.png)

发送端窗口是由接收窗口剩余大小决定的。接收方会把当前接收窗口的剩余大小写入应答报文，发送端收到应答后根据该值和当前网络拥塞情况设置发送窗口的大小，所以发送窗口的大小是不断变化的。

当发送端接收到应答报文后，会随之将窗口进行滑动

![](./images/tcpwindow2.png)

滑动窗口实现了流量控制。接收方通过报文告知发送方还可以发送多少数据，从而保证接收方能够来得及接收数据

#### Zero窗口

在发送报文的过程中，可能会遇到对端出现零窗口的情况。在该情况下，发送端会停止发送数据，并启动 persistent timer 。该定时器会定时发送请求给对端，让对端告知窗口大小。在重试次数超过一定次数后，可能会中断 TCP 链接

### 拥塞处理

拥塞处理和流量控制不同，后者是作用于接收方，保证接收方来得及接受数据。而前者是作用于网络，防止过多的数据拥塞网络，避免出现网络负载过大的情况。

拥塞处理包括了四个算法，分别为：慢开始，拥塞避免，快速重传，快速恢复。

#### 慢开始算法

慢开始算法，顾名思义就是在传输开始时将发送窗口慢慢指数级扩大，从而避免一开始就传输大量数据导致网络拥塞。

慢开始算法步骤具体如下：

1. 连接初始设置拥塞窗口（Congestion Window）为1 MSS一个分段的最大数据量）
2. 每过一个RTT就将窗口大小乘二
3. 指数级增长肯定不能没有限制的，所以有一个阀值限制，当窗口大小大于阀值时就会启动拥塞避免算法

#### 拥塞避免算法

拥塞避免算法相比简单点，每过一个RTT窗口大小只加一，这样能够避免指数级增长导致网络拥塞，慢慢将大小调整到最佳值。

在传输过程中可能定时间超时的情况，这时候TCP会认为网络拥塞了，会马上进行以下步骤：

1. 将阀值设为当前拥塞窗口的一半
2. 将拥塞窗口设为1 MSS
3. 启动拥塞避免算法

#### 快速重传

快速重传一般和快恢复一起出现。一旦接收端收到的报文出现失序的情况，接收端只会回复最后一个顺序正确的报文序号。如果收到三个重复的ACK，无需等待定时器超时再重发而是启动快速重传。具体算法分为两种：

TCP Taho 实现如下

* 将阀值设为当前拥塞窗口的一半
* 将拥塞窗口设为1 MSS
* 重新开始慢开始算法

TCP Reno 实现如下

* 拥塞窗口减半
* 将阀值设为当前拥塞窗口
* 进入快恢复阶段（重发对端需要的包，一旦收到一个新的 ACK 答复就退出该阶段）
* 使用拥塞避免算法

TCP New Ren 改进后的快恢复

TCP New Reno 算法改进了之前 TCP Reno 算法的缺陷。在之前，快恢复中只要收到一个新的 ACK 包，就会退出快恢复。

在 TCP New Reno 中，TCP 发送方先记下三个重复 ACK 的分段的最大序号。

假如我有一个分段数据是 1 ~ 10 这十个序号的报文，其中丢失了序号为 3 和 7 的报文，那么该分段的最大序号就是 10。发送端只会收到 ACK 序号为 3 的应答。这时候重发序号为 3 的报文，接收方顺利接收并会发送 ACK 序号为 7 的应答。这时候 TCP 知道对端是有多个包未收到，会继续发送序号为 7 的报文，接收方顺利接收并会发送 ACK 序号为 11 的应答，这时发送端认为这个分段接收端已经顺利接收，接下来会退出快恢复阶段。

## UDP协议

UDP 是User Datagram Protocol的简称， 中文名是用户数据报协议，是OSI（Open System Interconnection，开放式系统互联） 参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务，IETF RFC 768是UDP的正式规范。UDP在IP报文的协议号是17。

### 特性

1. UDP是面向报文的

UDP 是一个面向报文（报文可以理解为一段段的数据）的协议。意思就是 UDP 只是报文的搬运工，不会对报文进行任何拆分和拼接操作

具体来说：
* 在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了
* 在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作

2. 不可靠性

* UDP 是无连接的，也就是说通信不需要建立和断开连接。
* 协议收到什么数据就传递什么数据，并且也不会备份数据，对方能不能收到是不关心的
* UDP 没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP。

3. 高效性

因为 UDP 没有 TCP 那么复杂，需要保证数据不丢失且有序到达。所以 UDP 的头部开销小，只有八字节，相比 TCP 的至少二十字节要少得多，在传输数据报文时是很高效的。

![](./images/udp.png)

头部包含了以下几个数据

* 两个十六位的端口号，分别为源端口（可选字段）和目标端口
* 整个数据报文的长度
* 整个数据报文的检验和（IPv4 可选 字段），该字段用于发现头部信息和数据中的错误

4. 一对多传输

UDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 UDP 提供了单播，多播，广播的功能。

### TCP协议和UDP协议的区别

1、TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接

2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付

3、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的 UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）

4、每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信

5、TCP首部开销20字节;UDP的首部开销小，只有8个字节

6、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道


## HTTP

HTTP 协议是 Hyper Text Transfer Protocol (超文本传输协议)的缩写，是用于从万维网服务器传输超文本到本来浏览器的传送协议。基于TCP/IP通信协议来传递数据。它是一个**无状态的请求/响应协议**

HTTP 使用统一资源标识符（Uniform Resource Identifiers, URI） 来传输数据和建立连接。URL是一种特殊类型的URI。

### Request

客户端发送一个HTTP请求到服务器的请求消息包括以下格式：请求行（request line）、请求头部（header）、空行和请求数据四个部分组成，下图给出了请求报文的一般格式。

![](./images/httprequest.png)

1. 第一部分： 请求行，用来说明请求类型，要访问的资源以及使用的HTTP的版本

2. 第二部分：请求头部，紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息

3. 第三部分：空行，请求头部后面的空行是必须的

4. 第四部分：请求数据也叫主体，可以添加任意的其他数据。

### Response

HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。

![](./images/httpresponse.jpg)

1. 第一部分： 状态行，由HTTP协议版本号，状态码，状态消息 三部分组成

2. 第二部分：消息报头，用来说明客户端要使用的一些附加信息

3. 第三部分：空行，消息报头后面的空行是必须的

4. 第四部分：响应正文，服务器返回客户端的文本信息

### 请求方式

HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。

HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。

1. GET      请求指定的页面信息，并返回实体主体。
2. HEAD     类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头
3. POST     向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致      新的资源的建立和/或已有资源的修改。
4. PUT      从客户端向服务器传送的数据取代指定的文档的内容。
5. DELETE   请求服务器删除指定的页面。
6. CONNECT  HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。
7. OPTIONS  允许客户端查看服务器的性能。
8. TRACE    回显服务器收到的请求，主要用于测试或诊断。

### POST 和 GET 的区别

先引入副作用和幂等的概念。

副作用指对服务器上的资源做改变，搜索是无副作用的，注册是副作用的。

幂等指发送 M 和 N 次请求（两者不相同且都大于 1），服务器上资源的状态一致，比如注册 10 个和 11 个帐号是不幂等的，对文章进行更改 10 次和 11 次是幂等的。

在规范的应用场景上说，Get 多用于无副作用，幂等的场景，例如搜索关键字。Post 多用于副作用，不幂等的场景，例如注册。

1. 从缓存的角度，GET 请求会被浏览器主动缓存下来，留下历史记录，而 POST 默认不会。
2. 从编码的角度，GET 只能进行 URL 编码，只能接收 ASCII 字符，而 POST 没有限制。
3. 从参数的角度，GET 一般放在 URL 中，因此不安全，POST 放在请求体中，更适合传输敏感信息。
4. 从幂等性的角度，GET是幂等的，而POST不是。(幂等表示执行相同的操作，结果也是相同的)
5. 从TCP的角度，GET 请求会把请求报文一次性发出去，而 POST 会分为两个 TCP 数据包，首先发 header 部分，如果服务器响应 100(continue)， 然后发 body 部分。(火狐浏览器除外，它的 POST 请求只发一个 TCP 包)


### 状态码

状态代码有三位数字组成，第一个数字定义了响应的类别，共分五种类别：

1xx: 指示信息 -- 表示请求已接收，继续处理

2xx: 成功 -- 表示请求已被成功接收、理解、接受

3xx: 重定向 -- 表示要完成请求必须进行更进一步的操作

4xx: 客户端错误 —- 表示请求有语法错误或请求无法实现

5xx: 服务器端错误 -- 表示服务器未能实现合法的请求

常见状态码：

2xx:

* 200 OK 表示从客户端发来的请求在服务器端被正确处理
* 204 No content 表示请求成功，但响应报文不含实体的主体部分
* 205 Reset Content 表示请求成功，但响应报文不含实体的主体部分，但是与204响应不同在于要求请求方重置内容
* 206 Partial Content 进行范围请求

3xx

* 301 Moved Permanently,永久性重定向，表示资源已被分配了新的URL
* 302 Found 临时性重定向，表示资源临时被分配了新的URL
* 303 See Other 表示资源存在着另一个URL，应使用GET方法获取资源
* 304 Not Modified 表示服务器允许访问资源，但因发生请求未满足条件的情况
* 307 Temporary Redirect 临时重定向 和302含义类似，但是期望客户端保持请求方法不变向新的地址发出请求

4xx 

* 400 Bad Request 请求报文存在语法错误
* 401 Unauthorized 表示发送的请求需要通过HTTP认证的认证信息
* 403 Forbidden 表示对请求资源的访问被服务器拒绝
* 404 Not Found 表示在服务器上没有找到请求的资源

5xx

* 500 Internal Server Error 表示服务器端在执行请求时发生了错误
* 501 Not Implemented 表示服务器不支持当前请求所需要的某个功能
* 502 Bad Gateway 服务器自身是正常的，但访问的时候出错了，啥错误咱也不知道。
* 503 Service Unavailable 表示服务器暂时处于超负载或正在停机维护，无法处理请求

### 请求头

协议头 | 说明 | 实例 | 状态
-- | -- | -- | --
Accept | 可接受的响应内容类型 | Accept:text/plain | 固定
Accept-Charset | 可接受的字符集 | Accept-Charset:utf-8 | 固定
Accept-Encoding | 可接受的响应式的编码方式 | Accept-Encoding：gzip，deflate | 固定
Authorization | 用于表示HTTP协议中需要认证资源的认证信息 | Authorization: Basic OSdjJGRpbjpvcGVuIANlc2SdDE== | 固定
Cache-Control | 用来指定当前的请求/回复中的，是否使用缓存机制。 | Cache-Control: no-cache | 固定
Connection | 客户端想要优先使用的连接类型 | Connection：keep-alive | 固定
Cookie | 由之前服务器通过Set-Cookie（见下文）设置的一个HTTP协议Cookie | Cookie: $Version=1; Skin=new; | 固定
Content-Length | 以8进制表示的请求体的长度 | Content-Length: 348 | 固定
Content-Type | 请求体的MIME类型 （用于POST和PUT请求中） | Content-Type: application/json | 固定
Date | 发送该消息的日期和时间（以RFC 7231中定义的"HTTP日期"格式来发送） | Date: Dec, 26 Dec 2015 17:30:00 GMT | 固定
Expect | 表示客户端要求服务器做出特定的行为 | Expect: 100-continue | 固定
From | 发起此请求的用户的邮件地址 | From: user@example.com | 固定
Host | 表示服务器的域名以及服务器所监听的端口号。如果所请求的端口是对应的服务的标准端口（80），则端口号可以省略。 | Host: 127.0.0.1:8002 | 固定
If-Match | 仅当客户端提供的实体与服务器上对应的实体相匹配时，才进行对应的操作。主要用于像 PUT 这样的方法中，仅当从用户上次更新某个资源后，该资源未被修改的情况下，才更新该资源。 | If-Match: "9jd00cdj34pss9ejqiw39d82f20d0ikd" | 固定
If-Modified-Since | 允许在对应的资源未被修改的情况下返回304未修改 | If-Modified-Since: Dec, 26 Dec 2015 17:30:00 GMT | 固定
If-None-Match | 允许在对应的内容未被修改的情况下返回304未修改（ 304 Not Modified ），参考 超文本传输协议 的实体标记 | If-None-Match: "9jd00cdj34pss9ejqiw39d82f20d0ikd" | 固定
Origin | 发起一个针对跨域资源共享的请求（该请求要求服务器在响应中加入一个Access-Control-Allow-Origin的消息头，表示访问控制所允许的来源）。 | Origin: http://www.baidu.com | 固定
Referer | 表示浏览器所访问的前一个页面，可以认为是之前访问页面的链接将浏览器带到了当前页面。 | Referer: http://www.baidu.com | 固定
User-Agent | 浏览器的身份标识字符串 | User-Agent: Mozilla/…… | 固定
Range | 表示请求某个实体的一部分，字节偏移以0开始。 | Range: bytes=500-999 | 固定

### 响应头

响应头 | 说明 | 示例 | 状态
-- | -- | -- | --
Access-Control-Allow-Origin | 指定那些网可以跨域资源共享 | Access-Control-Allow-Origin: * | 临时
Cache-Control | 通知从服务器到客户端内的所有缓存机制，表示它们是否可以缓存这个对象及缓存有效时间。其单位为秒 | Cache-Control: max-age=3600 | 固定
Connection | 针对该连接所预期的选项 | Connection: close | 固定
Content-Type | 当前内容的MIME类型 | Content-Type: text/html; charset=utf-8 | 固定
ETag | 对于某个资源的某个特定版本的一个标识符，通常是一个 消息散列 | ETag: "737060cd8c284d8af7ad3082f209582d" | 固定
Last-Modified | 所请求的对象的最后修改日期(按照 RFC 7231 中定义的“超文本传输协议日期”格式来表示) | Last-Modified: Dec, 26 Dec 2015 17:30:00 GMT | 固定
Set-Cookie | 设置HTTP cookie | Set-Cookie: UserID=itbilu; Max-Age=3600; Version=1 | 固定
Status | 通用网关接口的响应头字段，用来说明当前HTTP连接的响应状态。 | Status: 200 OK | 